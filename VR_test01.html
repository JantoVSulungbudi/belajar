<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Babylon.js — Google Cardboard VR Demo</title>
  <!-- Babylon.js CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <style>
    html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    .hint { position: absolute; left: 12px; top: 12px; background: rgba(0,0,0,0.45); color: white; padding: 8px 10px; border-radius: 6px; font-family: sans-serif; font-size: 13px; }
    .center-btn { position: absolute; right: 12px; top: 12px; z-index: 5; }
    button { padding: 10px 14px; font-size: 14px; }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div class="hint">Tap the VR button to enter VR. In Cardboard mode use device rotation to look around. Tap the screen to spawn a ring where you are looking.</div>
  <div class="center-btn">
    <button id="enter-vr">Enter VR</button>
  </div>

  <script>
    (async function() {
      const canvas = document.getElementById('renderCanvas');
      const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

      const createScene = function() {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.07, 1);

        // Environment
        const ground = BABYLON.MeshBuilder.CreateGround('ground', {width:80, height:80}, scene);
        const groundMat = new BABYLON.StandardMaterial('gndMat', scene);
        groundMat.diffuseColor = new BABYLON.Color3(0.12, 0.12, 0.13);
        ground.material = groundMat;

        // Light & environment
        const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
        hemi.intensity = 0.9;

        // A dynamic rotating centerpiece
        const torus = BABYLON.MeshBuilder.CreateTorus('torus', {thickness:0.6, diameter:4}, scene);
        torus.position = new BABYLON.Vector3(0, 2, 4);
        const torusMat = new BABYLON.StandardMaterial('tMat', scene);
        torusMat.emissiveColor = new BABYLON.Color3(0.12, 0.6, 1.0);
        torus.material = torusMat;

        // Orbiting sphere
        const orb = BABYLON.MeshBuilder.CreateSphere('orb', {diameter:0.6}, scene);
        orb.position = new BABYLON.Vector3(3, 2.6, 4);
        const orbMat = new BABYLON.StandardMaterial('oMat', scene);
        orbMat.emissiveColor = new BABYLON.Color3(1.0, 0.6, 0.12);
        orb.material = orbMat;

        // Some floating platforms
        for (let i=0;i<8;i++){
          const box = BABYLON.MeshBuilder.CreateBox('box'+i, {size:0.8}, scene);
          const a = (i / 8) * Math.PI * 2;
          box.position = new BABYLON.Vector3(Math.cos(a)*6, 1.2 + Math.sin(a*2)*0.6, 4 + Math.sin(a)*6);
          box.rotation.y = a;
        }

        // Non-VR camera (used as a fallback for desktops)
        const cam = new BABYLON.ArcRotateCamera('arcCam', -Math.PI/2, Math.PI/3, 15, new BABYLON.Vector3(0,1.5,4), scene);
        cam.attachControl(canvas, true);

        // Small GUI text in scene
        const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI');
        const label = new BABYLON.GUI.TextBlock();
        label.text = 'Babylon.js — Cardboard VR demo';
        label.color = 'white';
        label.fontSize = 18;
        label.top = '10px';
        label.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        label.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        advancedTexture.addControl(label);

        // Simple animation
        scene.registerBeforeRender(function() {
          const t = performance.now() * 0.001;
          torus.rotation.x = t * 0.3;
          torus.rotation.y = t * 0.5;
          orb.position.x = 3 * Math.cos(t * 1.2);
          orb.position.z = 4 + 3 * Math.sin(t * 1.2);
        });

        return { scene, ground };
      };

      const { scene, ground } = createScene();

      // Create WebXR default experience (async)
      let xr = null;
      try {
        // createDefaultXRExperienceAsync works with immersive-vr where supported
        xr = await scene.createDefaultXRExperienceAsync({floorMeshes: [ground]});
      } catch (e) {
        console.warn('WebXR not available or failed to initialize:', e);
        xr = null;
      }

      // Reticle (gaze pointer) that always sits on the surface the camera is looking at
      const reticle = BABYLON.MeshBuilder.CreateDisc('reticle', {radius: 0.15, tessellation: 32}, scene);
      reticle.rotation.x = Math.PI/2; // face up so we can see it from above
      reticle.isPickable = false;
      const retMat = new BABYLON.StandardMaterial('rMat', scene);
      retMat.emissiveColor = new BABYLON.Color3(0.9, 0.9, 0.2);
      reticle.material = retMat;

      // Helper to update reticle position using a forward ray from the active camera (VR or fallback)
      const updateReticle = () => {
        const cam = scene.activeCamera;
        if (!cam) return;
        const origin = cam.position;
        // direction: camera forward
        const forward = cam.getForwardRay ? cam.getForwardRay().direction : new BABYLON.Vector3(0,0,1);
        const ray = new BABYLON.Ray(origin, forward, 100);
        const pick = scene.pickWithRay(ray, (mesh) => mesh === ground || mesh.name.startsWith('box') || mesh === torus || mesh === orb);
        if (pick && pick.hit) {
          reticle.position.copyFrom(pick.pickedPoint);
          reticle.isVisible = true;
          // make it hover a little above surface
          reticle.position.y += 0.01;
        } else {
          // place far in front
          const frontPos = origin.add(forward.scale(6));
          reticle.position.copyFrom(frontPos);
          reticle.isVisible = true;
        }
      };

      scene.onBeforeRenderObservable.add(updateReticle);

      // When in XR, disable the non-VR camera inputs
      if (xr) {
        xr.baseExperience.onStateChangedObservable.add((state) => {
          // states: XRSTATE_ENTERING_XR, XRSTATE_IN_XR, XRSTATE_EXITING_XR, XRSTATE_NOT_IN_XR
          // we leave behavior simple
          // Note: controllers may be available on some devices; Cardboard usually won't have controllers
        });

        // Make taps / screen touches create a ripple where the reticle is
        canvas.addEventListener('pointerdown', () => {
          spawnRing(reticle.position);
        });
      } else {
        // WebXR unavailable: still allow pointer taps in the 3D view
        canvas.addEventListener('pointerdown', (evt) => {
          const pick = scene.pick(evt.clientX, evt.clientY);
          if (pick && pick.hit) spawnRing(pick.pickedPoint);
        });
      }

      // Function to spawn a ring effect where user tapped / looked
      function spawnRing(position){
        const ring = BABYLON.MeshBuilder.CreateTorus('ring', {thickness:0.08, diameter:1.0}, scene);
        ring.position = position.clone();
        ring.position.y += 0.05;
        const mat = new BABYLON.StandardMaterial('rm', scene);
        mat.emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
        ring.material = mat;
        let life = 0;
        const up = scene.onBeforeRenderObservable.add(() => {
          life += engine.getDeltaTime() * 0.001;
          ring.scaling = new BABYLON.Vector3(1 + life*2,1 + life*2,1 + life*2);
          ring.rotation.y += 0.05;
          (mat.emissiveColor).scaleInPlace(0.995);
          if (life > 1.5) {
            ring.dispose();
            scene.onBeforeRenderObservable.removeCallback(up);
          }
        });
      }

      // Hook the "Enter VR" button to request XR session (or fallback to fullscreen)
      const enterVrBtn = document.getElementById('enter-vr');
      enterVrBtn.addEventListener('click', async () => {
        if (xr && xr.baseExperience) {
          try {
            await xr.baseExperience.enterXRAsync('immersive-vr', 'local-floor');
          } catch (err) {
            console.warn('Failed to enter XR session:', err);
            // fallback: go fullscreen
            if (document.fullscreenEnabled) await canvas.requestFullscreen();
          }
        } else {
          // no XR: try DeviceOrientationCamera for Cardboard-like view on mobile
          try {
            // Create a device orientation camera and set it active
            const devCam = new BABYLON.DeviceOrientationCamera('devcam', new BABYLON.Vector3(0,1.6,0), scene);
            scene.activeCamera = devCam;
            devCam.attachControl(canvas, true);
            if (document.fullscreenEnabled) await canvas.requestFullscreen();
          } catch (e) {
            if (document.fullscreenEnabled) await canvas.requestFullscreen();
          }
        }
      });

      // Render loop
      engine.runRenderLoop(function() {
        scene.render();
      });

      // Resize
      window.addEventListener('resize', function(){ engine.resize(); });

      // Helpful console message
      console.log('Demo loaded. To use with Google Cardboard: open this page on a modern mobile browser (Chrome/Edge on Android), serve via https or localhost, tap "Enter VR", put phone in Cardboard and look around.');

    })();
  </script>
</body>
</html>